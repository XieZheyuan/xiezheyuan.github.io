{"posts":[{"title":"数论分块简单笔记","content":"简介 数论分块可以在 O(n)O(\\sqrt{n})O(n​) 的时间复杂度内计算以下式子： ∑i=1nf(⌊ni⌋)\\sum_{i=1}^{n}{f(\\lfloor\\frac{n}{i}\\rfloor)} i=1∑n​f(⌊in​⌋) 阅读本篇题解，您需要： 知道一些基础的数论知识 大致了解分块思想（如果不了解，可以看 OI-Wiki上的介绍），简而述之，就是将数据进行一些适当的划分，结合一些适当的处理，使得较一般的暴力算法取得较为优秀的时间复杂度。 基本思路 下面用 f(x)=⌊12x⌋f(x)=\\lfloor\\frac{12}{x}\\rfloorf(x)=⌊x12​⌋ 举例： 可以看到，这个函数大致呈反比例，但是存在一段段的值是相等的。 不难证明以下结论： ⌊ni⌋=⌊n⌊ni⌋⌋\\lfloor\\frac{n}{i}\\rfloor=\\lfloor\\frac{n}{\\lfloor\\frac{n}{i}\\rfloor}\\rfloor ⌊in​⌋=⌊⌊in​⌋n​⌋ 然后我们就可以遍历一遍，对于每一个遍历到的值，我们找出它的右端点 ⌊n⌊ni⌋⌋\\lfloor\\frac{n}{\\lfloor\\frac{n}{i}\\rfloor}\\rfloor⌊⌊in​⌋n​⌋ ，累加区间的值，然后跳到 ⌊n⌊ni⌋⌋+1\\lfloor\\frac{n}{\\lfloor\\frac{n}{i}\\rfloor}\\rfloor+1⌊⌊in​⌋n​⌋+1 即可。 这种算法时间复杂度为 O(n)O(\\sqrt{n})O(n​)，比朴素的 O(n)O(n)O(n) 好多了。 UVA11526 H(n) 有 T(1≤T≤1000)T(1 \\leq T \\leq 1000)T(1≤T≤1000) 组数据，每组数据给出一个 n(0≤n≤231−1)n(0 \\leq n \\leq 2^{31}-1)n(0≤n≤231−1)，计算以下式子： ∑i=1n⌊ni⌋\\sum_{i=1}^{n}{\\lfloor\\frac{n}{i}\\rfloor} i=1∑n​⌊in​⌋ 模板题，我们可以直接套数论分块。 时间复杂度 O(Tn)O(T\\sqrt{n})O(Tn​)，空间复杂度 O(1)O(1)O(1)。 #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; int t; int solve(int n){ int ret=0; for(int i=1,j=0;i&lt;=n;i=j+1){ j=n/(n/i); ret+=(j-i+1)*(n/i); } return ret; } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin&gt;&gt;t; while(t--){ int n; cin&gt;&gt;n; cout&lt;&lt;solve(n)&lt;&lt;'\\n'; } return 0; } P3935 Calculating 原题面：若 xxx 分解质因数结果为 x=p1k1p2k2⋯pnknx=p_1^{k_1}p_2^{k_2}\\cdots p_n^{k_n}x=p1k1​​p2k2​​⋯pnkn​​，令f(x)=(k1+1)(k2+1)⋯(kn+1)f(x)=(k_1+1)(k_2+1)\\cdots (k_n+1)f(x)=(k1​+1)(k2​+1)⋯(kn​+1)，求 ∑i=lrf(i)\\sum_{i=l}^rf(i)∑i=lr​f(i) 对 998 244 353998\\,244\\,353998244353 取模的结果。 给出一个区间 [l,r][l,r][l,r]，定义函数 f(x)f(x)f(x)，为 xxx 的因数个数，求： ∑i=lrf(i)(mod998244353)\\sum_{i=l}^{r}{f(i)} \\pmod{998244353} i=l∑r​f(i)(mod998244353) 1≤l≤1014,1≤r≤1.6×1014,1014&lt;r−l1\\le l \\le 10^{14},1\\le r \\le 1.6\\times 10^{14},10^{14} \\lt r-l1≤l≤1014,1≤r≤1.6×1014,1014&lt;r−l 首先前缀和，定义 g(x)=∑i=1xf(x)g(x)=\\sum\\limits_{i=1}^{x}{f(x)}g(x)=i=1∑x​f(x)，那么答案就是 (g(r)−g(l−1)) mod 998244353(g(r)-g(l-1) )\\bmod{998244353}(g(r)−g(l−1))mod998244353。 然后就是推式子： ∑i=1xf(x)=∑i=1x∑j∣i1=∑j=1x∑i=1⌊xj⌋1=∑j=1x⌊xj⌋\\begin{aligned} &amp;\\sum_{i=1}^{x}{f(x)} \\\\ &amp;=\\sum_{i=1}^{x}{\\sum_{j|i}{1}} \\\\ &amp;=\\sum_{j=1}^{x}{\\sum_{i=1}^{\\lfloor\\frac{x}{j}\\rfloor}{1}} \\\\ &amp;=\\sum_{j=1}^{x}{\\lfloor\\frac{x}{j}\\rfloor} \\end{aligned} ​i=1∑x​f(x)=i=1∑x​j∣i∑​1=j=1∑x​i=1∑⌊jx​⌋​1=j=1∑x​⌊jx​⌋​ 好的，现在就可以数论分块了。 时间复杂度 O(n)O(\\sqrt{n})O(n​)。 代码如下： #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; int l,r; const int mod=998244353; int solve(int n){ int ret=0; for(int i=1,j=0;i&lt;=n;i=j+1){ j=n/(n/i); ret+=(j-i+1)*(n/i); ret%=mod; } return ret%mod; } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;((solve(r)-solve(l-1))%mod+mod)%mod&lt;&lt;'\\n'; return 0; } P1403 [AHOI2005]约数研究 原题面：科学家们在 Samuel 星球上的探险得到了丰富的能源储备，这使得空间站中大型计算机 Samuel II 的长时间运算成为了可能。由于在去年一年的辛苦工作取得了不错的成绩，小联被允许用 Samuel II 进行数学研究。小联最近在研究和约数有关的问题，他统计每个正数 NNN 的约数的个数，并以 f(N)f(N)f(N) 来表示。例如 121212 的约数有 1,2,3,4,6,121,2,3,4,6,121,2,3,4,6,12，因此 f(12)=6f(12)=6f(12)=6。现在请你求出：∑i=1nf(i)\\sum_{i=1}^n f(i)∑i=1n​f(i) 数据满足 1≤N≤1061 \\leq N \\leq 10^61≤N≤106 将上一题的区间 [l,r][l,r][l,r] 改成 [1,N][1,N][1,N] 就可以解决本题。 （本题数据太小，O(n)O(n)O(n) 暴力可过） 时间复杂度 O(n)O(\\sqrt{n})O(n​)，代码如下： #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; int l,r; int solve(int n){ int ret=0; for(int i=1,j=0;i&lt;=n;i=j+1){ j=n/(n/i); ret+=(j-i+1)*(n/i); } return ret; } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cin&gt;&gt;l; cout&lt;&lt;solve(l)&lt;&lt;'\\n'; return 0; } P2261 [CQOI2007]余数求和 给出 n,k(1≤n,k≤109)n,k(1 \\leq n, k \\leq 10^9)n,k(1≤n,k≤109)，计算： ∑i=1nk mod i\\sum_{i = 1}^n k \\bmod i i=1∑n​kmodi 小清新省选题。 首先，这个式子和上面的模板式子不一样，我们可以进行转换： ∑i=1nk mod i=∑i=1nk−i⋅⌊ki⌋=nk−∑i=1ni⋅⌊ki⌋\\begin{aligned} &amp;\\sum_{i = 1}^n k \\bmod i \\\\ &amp;=\\sum_{i=1}^{n}{k-i\\cdot \\lfloor\\frac{k}{i}\\rfloor} \\\\ &amp;=nk-\\sum_{i=1}^{n}{i\\cdot \\lfloor\\frac{k}{i}\\rfloor} \\end{aligned} ​i=1∑n​kmodi=i=1∑n​k−i⋅⌊ik​⌋=nk−i=1∑n​i⋅⌊ik​⌋​ 然后考虑怎么计算烦人的系数 iii。 对于一个块 [l,r][l,r][l,r] 中的任意元素 i,ji,ji,j，显然存在： ⌊ki⌋=⌊kj⌋\\lfloor\\frac{k}{i}\\rfloor=\\lfloor\\frac{k}{j}\\rfloor ⌊ik​⌋=⌊jk​⌋ 然后我们计算块内元素就可以变形： ∑i=lri⋅⌊ki⌋=⌊kl⌋⋅∑i=lri=⌊kl⌋⋅(l+r)(r−l+1)2\\begin{aligned} &amp;\\sum_{i=l}^{r}{i\\cdot \\lfloor\\frac{k}{i}\\rfloor} \\\\ &amp;=\\lfloor\\frac{k}{l}\\rfloor \\cdot \\sum_{i=l}^{r}{i} \\\\ &amp;=\\lfloor\\frac{k}{l}\\rfloor\\cdot\\frac{(l+r)(r-l+1)}{2} \\\\ \\end{aligned} ​i=l∑r​i⋅⌊ik​⌋=⌊lk​⌋⋅i=l∑r​i=⌊lk​⌋⋅2(l+r)(r−l+1)​​ 就可以算了。 注意可能存在 ⌊kl⌋=0\\lfloor\\frac{k}{l}\\rfloor =0⌊lk​⌋=0，这时我们直接 r=nr=nr=n，否则 r=min⁡{⌊n⌊nl⌋⌋,n}r=\\min\\{\\lfloor\\frac{n}{\\lfloor\\frac{n}{l}\\rfloor}\\rfloor,n\\}r=min{⌊⌊ln​⌋n​⌋,n}。 时间复杂度 O(n)O(\\sqrt{n})O(n​)，空间复杂度 O(1)O(1)O(1)。 代码如下： #include &lt;bits/stdc++.h&gt; #define int long long using namespace std; int n,k; int solve(){ int ret=0; for(int i=1,j=0;i&lt;=n;i=j+1){ if(k/i==0){ j=n; } else j=min(k/(k/i),n); ret+=(((j-i+1)*(k/i)*(i+j))&gt;&gt;1); } return n*k-ret; } signed main(){ cin&gt;&gt;n&gt;&gt;k; cout&lt;&lt;solve()&lt;&lt;'\\n'; return 0; } P2260 [清华集训2012]模积和 给出任意两个整数 n,m(1≤n,m≤109)n,m(1 \\leq n,m \\leq 10^9)n,m(1≤n,m≤109)，计算： ∑i=1n∑j=1m(n mod i)×(m mod j),i≠j(mod19940417)\\sum_{i=1}^{n} \\sum_{j=1}^{m} (n \\bmod i) \\times (m \\bmod j), i \\neq j \\pmod{19940417} i=1∑n​j=1∑m​(nmodi)×(mmodj),i​=j(mod19940417) 已经A了，讲解先咕咕了。 ","link":"http://xiezheyuan.com.cn/post/number-theory-sqrt-decomposition/"}]}